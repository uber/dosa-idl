// Code generated by thriftrw v1.1.0
// @generated

package dosa

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"go.uber.org/thriftrw/wire"
	"math"
	"strconv"
	"strings"
)

type BadRequestError struct {
	Err       string  `json:"err"`
	Message   *string `json:"message,omitempty"`
	ErrorCode *int32  `json:"errorCode,omitempty"`
}

func (v *BadRequestError) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	w, err = wire.NewValueString(v.Err), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.Message != nil {
		w, err = wire.NewValueString(*(v.Message)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.ErrorCode != nil {
		w, err = wire.NewValueI32(*(v.ErrorCode)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *BadRequestError) FromWire(w wire.Value) error {
	var err error
	errIsSet := false
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.Err, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				errIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Message = &x
				if err != nil {
					return err
				}
			}
		case 3:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.ErrorCode = &x
				if err != nil {
					return err
				}
			}
		}
	}
	if !errIsSet {
		return errors.New("field Err of BadRequestError is required")
	}
	return nil
}

func (v *BadRequestError) String() string {
	if v == nil {
		return "<nil>"
	}
	var fields [3]string
	i := 0
	fields[i] = fmt.Sprintf("Err: %v", v.Err)
	i++
	if v.Message != nil {
		fields[i] = fmt.Sprintf("Message: %v", *(v.Message))
		i++
	}
	if v.ErrorCode != nil {
		fields[i] = fmt.Sprintf("ErrorCode: %v", *(v.ErrorCode))
		i++
	}
	return fmt.Sprintf("BadRequestError{%v}", strings.Join(fields[:i], ", "))
}

func _string_EqualsPtr(lhs, rhs *string) bool {
	if lhs != nil && rhs != nil {
		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _i32_EqualsPtr(lhs, rhs *int32) bool {
	if lhs != nil && rhs != nil {
		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func (v *BadRequestError) Equals(rhs *BadRequestError) bool {
	if !(v.Err == rhs.Err) {
		return false
	}
	if !_string_EqualsPtr(v.Message, rhs.Message) {
		return false
	}
	if !_i32_EqualsPtr(v.ErrorCode, rhs.ErrorCode) {
		return false
	}
	return true
}

func (v *BadRequestError) Error() string {
	return v.String()
}

type BadSchemaError struct {
	Reasons []struct {
		Key   *SchemaRef
		Value string
	} `json:"reasons"`
}

type _Map_SchemaRef_String_MapItemList []struct {
	Key   *SchemaRef
	Value string
}

func (m _Map_SchemaRef_String_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for _, i := range m {
		k := i.Key
		v := i.Value
		if k == nil {
			return fmt.Errorf("invalid map key: value is nil")
		}
		kw, err := k.ToWire()
		if err != nil {
			return err
		}
		vw, err := wire.NewValueString(v), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_SchemaRef_String_MapItemList) Size() int {
	return len(m)
}

func (_Map_SchemaRef_String_MapItemList) KeyType() wire.Type {
	return wire.TStruct
}

func (_Map_SchemaRef_String_MapItemList) ValueType() wire.Type {
	return wire.TBinary
}

func (_Map_SchemaRef_String_MapItemList) Close() {
}

func (v *BadSchemaError) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Reasons == nil {
		return w, errors.New("field Reasons of BadSchemaError is required")
	}
	w, err = wire.NewValueMap(_Map_SchemaRef_String_MapItemList(v.Reasons)), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _SchemaRef_Read(w wire.Value) (*SchemaRef, error) {
	var v SchemaRef
	err := v.FromWire(w)
	return &v, err
}

func _Map_SchemaRef_String_Read(m wire.MapItemList) ([]struct {
	Key   *SchemaRef
	Value string
}, error) {
	if m.KeyType() != wire.TStruct {
		return nil, nil
	}
	if m.ValueType() != wire.TBinary {
		return nil, nil
	}
	o := make([]struct {
		Key   *SchemaRef
		Value string
	}, 0, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := _SchemaRef_Read(x.Key)
		if err != nil {
			return err
		}
		v, err := x.Value.GetString(), error(nil)
		if err != nil {
			return err
		}
		o = append(o, struct {
			Key   *SchemaRef
			Value string
		}{k, v})
		return nil
	})
	m.Close()
	return o, err
}

func (v *BadSchemaError) FromWire(w wire.Value) error {
	var err error
	reasonsIsSet := false
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TMap {
				v.Reasons, err = _Map_SchemaRef_String_Read(field.Value.GetMap())
				if err != nil {
					return err
				}
				reasonsIsSet = true
			}
		}
	}
	if !reasonsIsSet {
		return errors.New("field Reasons of BadSchemaError is required")
	}
	return nil
}

func (v *BadSchemaError) String() string {
	if v == nil {
		return "<nil>"
	}
	var fields [1]string
	i := 0
	fields[i] = fmt.Sprintf("Reasons: %v", v.Reasons)
	i++
	return fmt.Sprintf("BadSchemaError{%v}", strings.Join(fields[:i], ", "))
}

func _Map_SchemaRef_String_EqualsUnhashable(lhs, rhs []struct {
	Key   *SchemaRef
	Value string
}) bool {
	if len(lhs) != len(rhs) {
		return false
	}
	for _, i := range lhs {
		lk := i.Key
		lv := i.Value
		ok := false
		for _, j := range rhs {
			rk := j.Key
			rv := j.Value
			if !lk.Equals(rk) {
				continue
			}
			if !(lv == rv) {
				return false
			}
			ok = true
			break
		}
		if !ok {
			return false
		}
	}
	return true
}

func (v *BadSchemaError) Equals(rhs *BadSchemaError) bool {
	if !_Map_SchemaRef_String_EqualsUnhashable(v.Reasons, rhs.Reasons) {
		return false
	}
	return true
}

func (v *BadSchemaError) Error() string {
	return v.String()
}

type BatchReadRequest struct {
	Ref          *SchemaRef          `json:"ref,omitempty"`
	KeyValues    []FieldValueMap     `json:"keyValues"`
	FieldsToRead map[string]struct{} `json:"fieldsToRead"`
}

type _List_FieldValueMap_ValueList []FieldValueMap

func (v _List_FieldValueMap_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_FieldValueMap_ValueList) Size() int {
	return len(v)
}

func (_List_FieldValueMap_ValueList) ValueType() wire.Type {
	return wire.TMap
}

func (_List_FieldValueMap_ValueList) Close() {
}

type _Set_String_ValueList map[string]struct{}

func (v _Set_String_ValueList) ForEach(f func(wire.Value) error) error {
	for x := range v {
		w, err := wire.NewValueString(x), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_String_ValueList) Size() int {
	return len(v)
}

func (_Set_String_ValueList) ValueType() wire.Type {
	return wire.TBinary
}

func (_Set_String_ValueList) Close() {
}

func (v *BatchReadRequest) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Ref != nil {
		w, err = v.Ref.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.KeyValues != nil {
		w, err = wire.NewValueList(_List_FieldValueMap_ValueList(v.KeyValues)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.FieldsToRead != nil {
		w, err = wire.NewValueSet(_Set_String_ValueList(v.FieldsToRead)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _FieldValueMap_Read(w wire.Value) (FieldValueMap, error) {
	var x FieldValueMap
	err := x.FromWire(w)
	return x, err
}

func _List_FieldValueMap_Read(l wire.ValueList) ([]FieldValueMap, error) {
	if l.ValueType() != wire.TMap {
		return nil, nil
	}
	o := make([]FieldValueMap, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _FieldValueMap_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func _Set_String_Read(s wire.ValueList) (map[string]struct{}, error) {
	if s.ValueType() != wire.TBinary {
		return nil, nil
	}
	o := make(map[string]struct{}, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := x.GetString(), error(nil)
		if err != nil {
			return err
		}
		o[i] = struct{}{}
		return nil
	})
	s.Close()
	return o, err
}

func (v *BatchReadRequest) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Ref, err = _SchemaRef_Read(field.Value)
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TList {
				v.KeyValues, err = _List_FieldValueMap_Read(field.Value.GetList())
				if err != nil {
					return err
				}
			}
		case 3:
			if field.Value.Type() == wire.TSet {
				v.FieldsToRead, err = _Set_String_Read(field.Value.GetSet())
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *BatchReadRequest) String() string {
	if v == nil {
		return "<nil>"
	}
	var fields [3]string
	i := 0
	if v.Ref != nil {
		fields[i] = fmt.Sprintf("Ref: %v", v.Ref)
		i++
	}
	if v.KeyValues != nil {
		fields[i] = fmt.Sprintf("KeyValues: %v", v.KeyValues)
		i++
	}
	if v.FieldsToRead != nil {
		fields[i] = fmt.Sprintf("FieldsToRead: %v", v.FieldsToRead)
		i++
	}
	return fmt.Sprintf("BatchReadRequest{%v}", strings.Join(fields[:i], ", "))
}

func _List_FieldValueMap_Equals(lhs, rhs []FieldValueMap) bool {
	if len(lhs) != len(rhs) {
		return false
	}
	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}
	return true
}

func _Set_String_Equals(lhs, rhs map[string]struct{}) bool {
	if len(lhs) != len(rhs) {
		return false
	}
	for x := range rhs {
		if _, ok := lhs[x]; !ok {
			return false
		}
	}
	return true
}

func (v *BatchReadRequest) Equals(rhs *BatchReadRequest) bool {
	if !((v.Ref == nil && rhs.Ref == nil) || (v.Ref != nil && rhs.Ref != nil && v.Ref.Equals(rhs.Ref))) {
		return false
	}
	if !((v.KeyValues == nil && rhs.KeyValues == nil) || (v.KeyValues != nil && rhs.KeyValues != nil && _List_FieldValueMap_Equals(v.KeyValues, rhs.KeyValues))) {
		return false
	}
	if !((v.FieldsToRead == nil && rhs.FieldsToRead == nil) || (v.FieldsToRead != nil && rhs.FieldsToRead != nil && _Set_String_Equals(v.FieldsToRead, rhs.FieldsToRead))) {
		return false
	}
	return true
}

type BatchReadResponse struct {
	Results []*EntityOrError `json:"results"`
}

type _List_EntityOrError_ValueList []*EntityOrError

func (v _List_EntityOrError_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_EntityOrError_ValueList) Size() int {
	return len(v)
}

func (_List_EntityOrError_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_List_EntityOrError_ValueList) Close() {
}

func (v *BatchReadResponse) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Results != nil {
		w, err = wire.NewValueList(_List_EntityOrError_ValueList(v.Results)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _EntityOrError_Read(w wire.Value) (*EntityOrError, error) {
	var v EntityOrError
	err := v.FromWire(w)
	return &v, err
}

func _List_EntityOrError_Read(l wire.ValueList) ([]*EntityOrError, error) {
	if l.ValueType() != wire.TStruct {
		return nil, nil
	}
	o := make([]*EntityOrError, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _EntityOrError_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func (v *BatchReadResponse) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.Results, err = _List_EntityOrError_Read(field.Value.GetList())
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *BatchReadResponse) String() string {
	if v == nil {
		return "<nil>"
	}
	var fields [1]string
	i := 0
	if v.Results != nil {
		fields[i] = fmt.Sprintf("Results: %v", v.Results)
		i++
	}
	return fmt.Sprintf("BatchReadResponse{%v}", strings.Join(fields[:i], ", "))
}

func _List_EntityOrError_Equals(lhs, rhs []*EntityOrError) bool {
	if len(lhs) != len(rhs) {
		return false
	}
	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}
	return true
}

func (v *BatchReadResponse) Equals(rhs *BatchReadResponse) bool {
	if !((v.Results == nil && rhs.Results == nil) || (v.Results != nil && rhs.Results != nil && _List_EntityOrError_Equals(v.Results, rhs.Results))) {
		return false
	}
	return true
}

type BatchRemoveRequest struct {
	Ref       *SchemaRef      `json:"ref,omitempty"`
	KeyValues []FieldValueMap `json:"keyValues"`
}

func (v *BatchRemoveRequest) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Ref != nil {
		w, err = v.Ref.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.KeyValues != nil {
		w, err = wire.NewValueList(_List_FieldValueMap_ValueList(v.KeyValues)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *BatchRemoveRequest) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Ref, err = _SchemaRef_Read(field.Value)
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TList {
				v.KeyValues, err = _List_FieldValueMap_Read(field.Value.GetList())
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *BatchRemoveRequest) String() string {
	if v == nil {
		return "<nil>"
	}
	var fields [2]string
	i := 0
	if v.Ref != nil {
		fields[i] = fmt.Sprintf("Ref: %v", v.Ref)
		i++
	}
	if v.KeyValues != nil {
		fields[i] = fmt.Sprintf("KeyValues: %v", v.KeyValues)
		i++
	}
	return fmt.Sprintf("BatchRemoveRequest{%v}", strings.Join(fields[:i], ", "))
}

func (v *BatchRemoveRequest) Equals(rhs *BatchRemoveRequest) bool {
	if !((v.Ref == nil && rhs.Ref == nil) || (v.Ref != nil && rhs.Ref != nil && v.Ref.Equals(rhs.Ref))) {
		return false
	}
	if !((v.KeyValues == nil && rhs.KeyValues == nil) || (v.KeyValues != nil && rhs.KeyValues != nil && _List_FieldValueMap_Equals(v.KeyValues, rhs.KeyValues))) {
		return false
	}
	return true
}

type BatchUpsertRequest struct {
	Ref      *SchemaRef      `json:"ref,omitempty"`
	Entities []FieldValueMap `json:"entities"`
}

func (v *BatchUpsertRequest) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Ref != nil {
		w, err = v.Ref.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Entities != nil {
		w, err = wire.NewValueList(_List_FieldValueMap_ValueList(v.Entities)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *BatchUpsertRequest) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Ref, err = _SchemaRef_Read(field.Value)
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TList {
				v.Entities, err = _List_FieldValueMap_Read(field.Value.GetList())
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *BatchUpsertRequest) String() string {
	if v == nil {
		return "<nil>"
	}
	var fields [2]string
	i := 0
	if v.Ref != nil {
		fields[i] = fmt.Sprintf("Ref: %v", v.Ref)
		i++
	}
	if v.Entities != nil {
		fields[i] = fmt.Sprintf("Entities: %v", v.Entities)
		i++
	}
	return fmt.Sprintf("BatchUpsertRequest{%v}", strings.Join(fields[:i], ", "))
}

func (v *BatchUpsertRequest) Equals(rhs *BatchUpsertRequest) bool {
	if !((v.Ref == nil && rhs.Ref == nil) || (v.Ref != nil && rhs.Ref != nil && v.Ref.Equals(rhs.Ref))) {
		return false
	}
	if !((v.Entities == nil && rhs.Entities == nil) || (v.Entities != nil && rhs.Entities != nil && _List_FieldValueMap_Equals(v.Entities, rhs.Entities))) {
		return false
	}
	return true
}

type CheckSchemaRequest struct {
	Scope      *Scope              `json:"scope,omitempty"`
	NamePrefix *NamePrefix         `json:"namePrefix,omitempty"`
	EntityDefs []*EntityDefinition `json:"entityDefs"`
}

type _List_EntityDefinition_ValueList []*EntityDefinition

func (v _List_EntityDefinition_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_EntityDefinition_ValueList) Size() int {
	return len(v)
}

func (_List_EntityDefinition_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_List_EntityDefinition_ValueList) Close() {
}

func (v *CheckSchemaRequest) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Scope != nil {
		w, err = v.Scope.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.NamePrefix != nil {
		w, err = v.NamePrefix.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.EntityDefs != nil {
		w, err = wire.NewValueList(_List_EntityDefinition_ValueList(v.EntityDefs)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Scope_Read(w wire.Value) (Scope, error) {
	var x Scope
	err := x.FromWire(w)
	return x, err
}

func _NamePrefix_Read(w wire.Value) (NamePrefix, error) {
	var x NamePrefix
	err := x.FromWire(w)
	return x, err
}

func _EntityDefinition_Read(w wire.Value) (*EntityDefinition, error) {
	var v EntityDefinition
	err := v.FromWire(w)
	return &v, err
}

func _List_EntityDefinition_Read(l wire.ValueList) ([]*EntityDefinition, error) {
	if l.ValueType() != wire.TStruct {
		return nil, nil
	}
	o := make([]*EntityDefinition, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _EntityDefinition_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func (v *CheckSchemaRequest) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x Scope
				x, err = _Scope_Read(field.Value)
				v.Scope = &x
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x NamePrefix
				x, err = _NamePrefix_Read(field.Value)
				v.NamePrefix = &x
				if err != nil {
					return err
				}
			}
		case 3:
			if field.Value.Type() == wire.TList {
				v.EntityDefs, err = _List_EntityDefinition_Read(field.Value.GetList())
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *CheckSchemaRequest) String() string {
	if v == nil {
		return "<nil>"
	}
	var fields [3]string
	i := 0
	if v.Scope != nil {
		fields[i] = fmt.Sprintf("Scope: %v", *(v.Scope))
		i++
	}
	if v.NamePrefix != nil {
		fields[i] = fmt.Sprintf("NamePrefix: %v", *(v.NamePrefix))
		i++
	}
	if v.EntityDefs != nil {
		fields[i] = fmt.Sprintf("EntityDefs: %v", v.EntityDefs)
		i++
	}
	return fmt.Sprintf("CheckSchemaRequest{%v}", strings.Join(fields[:i], ", "))
}

func _Scope_EqualsPtr(lhs, rhs *Scope) bool {
	if lhs != nil && rhs != nil {
		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _NamePrefix_EqualsPtr(lhs, rhs *NamePrefix) bool {
	if lhs != nil && rhs != nil {
		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _List_EntityDefinition_Equals(lhs, rhs []*EntityDefinition) bool {
	if len(lhs) != len(rhs) {
		return false
	}
	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}
	return true
}

func (v *CheckSchemaRequest) Equals(rhs *CheckSchemaRequest) bool {
	if !_Scope_EqualsPtr(v.Scope, rhs.Scope) {
		return false
	}
	if !_NamePrefix_EqualsPtr(v.NamePrefix, rhs.NamePrefix) {
		return false
	}
	if !((v.EntityDefs == nil && rhs.EntityDefs == nil) || (v.EntityDefs != nil && rhs.EntityDefs != nil && _List_EntityDefinition_Equals(v.EntityDefs, rhs.EntityDefs))) {
		return false
	}
	return true
}

type CheckSchemaResponse struct {
	Versions []Version `json:"versions"`
}

type _List_Version_ValueList []Version

func (v _List_Version_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Version_ValueList) Size() int {
	return len(v)
}

func (_List_Version_ValueList) ValueType() wire.Type {
	return wire.TI32
}

func (_List_Version_ValueList) Close() {
}

func (v *CheckSchemaResponse) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Versions != nil {
		w, err = wire.NewValueList(_List_Version_ValueList(v.Versions)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Version_Read(w wire.Value) (Version, error) {
	var x Version
	err := x.FromWire(w)
	return x, err
}

func _List_Version_Read(l wire.ValueList) ([]Version, error) {
	if l.ValueType() != wire.TI32 {
		return nil, nil
	}
	o := make([]Version, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _Version_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func (v *CheckSchemaResponse) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.Versions, err = _List_Version_Read(field.Value.GetList())
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *CheckSchemaResponse) String() string {
	if v == nil {
		return "<nil>"
	}
	var fields [1]string
	i := 0
	if v.Versions != nil {
		fields[i] = fmt.Sprintf("Versions: %v", v.Versions)
		i++
	}
	return fmt.Sprintf("CheckSchemaResponse{%v}", strings.Join(fields[:i], ", "))
}

func _List_Version_Equals(lhs, rhs []Version) bool {
	if len(lhs) != len(rhs) {
		return false
	}
	for i, lv := range lhs {
		rv := rhs[i]
		if !(lv == rv) {
			return false
		}
	}
	return true
}

func (v *CheckSchemaResponse) Equals(rhs *CheckSchemaResponse) bool {
	if !((v.Versions == nil && rhs.Versions == nil) || (v.Versions != nil && rhs.Versions != nil && _List_Version_Equals(v.Versions, rhs.Versions))) {
		return false
	}
	return true
}

type ClusteringKey struct {
	Name *string `json:"name,omitempty"`
	Asc  *bool   `json:"asc,omitempty"`
}

func (v *ClusteringKey) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Name != nil {
		w, err = wire.NewValueString(*(v.Name)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Asc != nil {
		w, err = wire.NewValueBool(*(v.Asc)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *ClusteringKey) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Name = &x
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.Asc = &x
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *ClusteringKey) String() string {
	if v == nil {
		return "<nil>"
	}
	var fields [2]string
	i := 0
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}
	if v.Asc != nil {
		fields[i] = fmt.Sprintf("Asc: %v", *(v.Asc))
		i++
	}
	return fmt.Sprintf("ClusteringKey{%v}", strings.Join(fields[:i], ", "))
}

func _bool_EqualsPtr(lhs, rhs *bool) bool {
	if lhs != nil && rhs != nil {
		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func (v *ClusteringKey) Equals(rhs *ClusteringKey) bool {
	if !_string_EqualsPtr(v.Name, rhs.Name) {
		return false
	}
	if !_bool_EqualsPtr(v.Asc, rhs.Asc) {
		return false
	}
	return true
}

type Condition struct {
	Op    *Operator `json:"op,omitempty"`
	Field *Field    `json:"field,omitempty"`
}

func (v *Condition) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Op != nil {
		w, err = v.Op.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Field != nil {
		w, err = v.Field.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Operator_Read(w wire.Value) (Operator, error) {
	var v Operator
	err := v.FromWire(w)
	return v, err
}

func _Field_Read(w wire.Value) (*Field, error) {
	var v Field
	err := v.FromWire(w)
	return &v, err
}

func (v *Condition) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x Operator
				x, err = _Operator_Read(field.Value)
				v.Op = &x
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.Field, err = _Field_Read(field.Value)
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *Condition) String() string {
	if v == nil {
		return "<nil>"
	}
	var fields [2]string
	i := 0
	if v.Op != nil {
		fields[i] = fmt.Sprintf("Op: %v", *(v.Op))
		i++
	}
	if v.Field != nil {
		fields[i] = fmt.Sprintf("Field: %v", v.Field)
		i++
	}
	return fmt.Sprintf("Condition{%v}", strings.Join(fields[:i], ", "))
}

func _Operator_EqualsPtr(lhs, rhs *Operator) bool {
	if lhs != nil && rhs != nil {
		x := *lhs
		y := *rhs
		return x.Equals(y)
	}
	return lhs == nil && rhs == nil
}

func (v *Condition) Equals(rhs *Condition) bool {
	if !_Operator_EqualsPtr(v.Op, rhs.Op) {
		return false
	}
	if !((v.Field == nil && rhs.Field == nil) || (v.Field != nil && rhs.Field != nil && v.Field.Equals(rhs.Field))) {
		return false
	}
	return true
}

type CreateRequest struct {
	Ref          *SchemaRef    `json:"ref,omitempty"`
	EntityValues FieldValueMap `json:"entityValues"`
}

func (v *CreateRequest) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Ref != nil {
		w, err = v.Ref.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.EntityValues != nil {
		w, err = v.EntityValues.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *CreateRequest) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Ref, err = _SchemaRef_Read(field.Value)
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TMap {
				v.EntityValues, err = _FieldValueMap_Read(field.Value)
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *CreateRequest) String() string {
	if v == nil {
		return "<nil>"
	}
	var fields [2]string
	i := 0
	if v.Ref != nil {
		fields[i] = fmt.Sprintf("Ref: %v", v.Ref)
		i++
	}
	if v.EntityValues != nil {
		fields[i] = fmt.Sprintf("EntityValues: %v", v.EntityValues)
		i++
	}
	return fmt.Sprintf("CreateRequest{%v}", strings.Join(fields[:i], ", "))
}

func (v *CreateRequest) Equals(rhs *CreateRequest) bool {
	if !((v.Ref == nil && rhs.Ref == nil) || (v.Ref != nil && rhs.Ref != nil && v.Ref.Equals(rhs.Ref))) {
		return false
	}
	if !((v.EntityValues == nil && rhs.EntityValues == nil) || (v.EntityValues != nil && rhs.EntityValues != nil && v.EntityValues.Equals(rhs.EntityValues))) {
		return false
	}
	return true
}

type CreateScopeRequest struct {
	Name *Scope `json:"name,omitempty"`
}

func (v *CreateScopeRequest) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Name != nil {
		w, err = v.Name.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *CreateScopeRequest) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x Scope
				x, err = _Scope_Read(field.Value)
				v.Name = &x
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *CreateScopeRequest) String() string {
	if v == nil {
		return "<nil>"
	}
	var fields [1]string
	i := 0
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}
	return fmt.Sprintf("CreateScopeRequest{%v}", strings.Join(fields[:i], ", "))
}

func (v *CreateScopeRequest) Equals(rhs *CreateScopeRequest) bool {
	if !_Scope_EqualsPtr(v.Name, rhs.Name) {
		return false
	}
	return true
}

type DropScopeRequest struct {
	Name *Scope `json:"name,omitempty"`
}

func (v *DropScopeRequest) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Name != nil {
		w, err = v.Name.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *DropScopeRequest) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x Scope
				x, err = _Scope_Read(field.Value)
				v.Name = &x
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *DropScopeRequest) String() string {
	if v == nil {
		return "<nil>"
	}
	var fields [1]string
	i := 0
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}
	return fmt.Sprintf("DropScopeRequest{%v}", strings.Join(fields[:i], ", "))
}

func (v *DropScopeRequest) Equals(rhs *DropScopeRequest) bool {
	if !_Scope_EqualsPtr(v.Name, rhs.Name) {
		return false
	}
	return true
}

type ElemType int32

const (
	ElemTypeBool      ElemType = 0
	ElemTypeBlob      ElemType = 1
	ElemTypeString    ElemType = 2
	ElemTypeInt32     ElemType = 3
	ElemTypeInt64     ElemType = 4
	ElemTypeDouble    ElemType = 5
	ElemTypeTimestamp ElemType = 6
	ElemTypeUUID      ElemType = 7
	ElemTypeReserved0 ElemType = 8
	ElemTypeReserved1 ElemType = 9
	ElemTypeReserved2 ElemType = 10
	ElemTypeReserved3 ElemType = 11
)

func (v ElemType) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

func (v *ElemType) FromWire(w wire.Value) error {
	*v = (ElemType)(w.GetI32())
	return nil
}

func (v ElemType) String() string {
	w := int32(v)
	switch w {
	case 0:
		return "BOOL"
	case 1:
		return "BLOB"
	case 2:
		return "STRING"
	case 3:
		return "INT32"
	case 4:
		return "INT64"
	case 5:
		return "DOUBLE"
	case 6:
		return "TIMESTAMP"
	case 7:
		return "UUID"
	case 8:
		return "RESERVED0"
	case 9:
		return "RESERVED1"
	case 10:
		return "RESERVED2"
	case 11:
		return "RESERVED3"
	}
	return fmt.Sprintf("ElemType(%d)", w)
}

func (v ElemType) Equals(rhs ElemType) bool {
	return v == rhs
}

func (v ElemType) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 0:
		return ([]byte)("\"BOOL\""), nil
	case 1:
		return ([]byte)("\"BLOB\""), nil
	case 2:
		return ([]byte)("\"STRING\""), nil
	case 3:
		return ([]byte)("\"INT32\""), nil
	case 4:
		return ([]byte)("\"INT64\""), nil
	case 5:
		return ([]byte)("\"DOUBLE\""), nil
	case 6:
		return ([]byte)("\"TIMESTAMP\""), nil
	case 7:
		return ([]byte)("\"UUID\""), nil
	case 8:
		return ([]byte)("\"RESERVED0\""), nil
	case 9:
		return ([]byte)("\"RESERVED1\""), nil
	case 10:
		return ([]byte)("\"RESERVED2\""), nil
	case 11:
		return ([]byte)("\"RESERVED3\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

func (v *ElemType) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}
	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "ElemType")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "ElemType")
		}
		*v = (ElemType)(x)
		return nil
	case string:
		switch w {
		case "BOOL":
			*v = ElemTypeBool
			return nil
		case "BLOB":
			*v = ElemTypeBlob
			return nil
		case "STRING":
			*v = ElemTypeString
			return nil
		case "INT32":
			*v = ElemTypeInt32
			return nil
		case "INT64":
			*v = ElemTypeInt64
			return nil
		case "DOUBLE":
			*v = ElemTypeDouble
			return nil
		case "TIMESTAMP":
			*v = ElemTypeTimestamp
			return nil
		case "UUID":
			*v = ElemTypeUUID
			return nil
		case "RESERVED0":
			*v = ElemTypeReserved0
			return nil
		case "RESERVED1":
			*v = ElemTypeReserved1
			return nil
		case "RESERVED2":
			*v = ElemTypeReserved2
			return nil
		case "RESERVED3":
			*v = ElemTypeReserved3
			return nil
		default:
			return fmt.Errorf("unknown enum value %q for %q", w, "ElemType")
		}
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "ElemType")
	}
}

type EntityDefinition struct {
	Name       *EntityName           `json:"name,omitempty"`
	FieldDescs map[string]*FieldDesc `json:"fieldDescs"`
	PrimaryKey *PrimaryKey           `json:"primaryKey,omitempty"`
}

type _Map_String_FieldDesc_MapItemList map[string]*FieldDesc

func (m _Map_String_FieldDesc_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := wire.NewValueString(k), error(nil)
		if err != nil {
			return err
		}
		vw, err := v.ToWire()
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_String_FieldDesc_MapItemList) Size() int {
	return len(m)
}

func (_Map_String_FieldDesc_MapItemList) KeyType() wire.Type {
	return wire.TBinary
}

func (_Map_String_FieldDesc_MapItemList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Map_String_FieldDesc_MapItemList) Close() {
}

func (v *EntityDefinition) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Name != nil {
		w, err = v.Name.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.FieldDescs != nil {
		w, err = wire.NewValueMap(_Map_String_FieldDesc_MapItemList(v.FieldDescs)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.PrimaryKey != nil {
		w, err = v.PrimaryKey.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _EntityName_Read(w wire.Value) (EntityName, error) {
	var x EntityName
	err := x.FromWire(w)
	return x, err
}

func _FieldDesc_Read(w wire.Value) (*FieldDesc, error) {
	var v FieldDesc
	err := v.FromWire(w)
	return &v, err
}

func _Map_String_FieldDesc_Read(m wire.MapItemList) (map[string]*FieldDesc, error) {
	if m.KeyType() != wire.TBinary {
		return nil, nil
	}
	if m.ValueType() != wire.TStruct {
		return nil, nil
	}
	o := make(map[string]*FieldDesc, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetString(), error(nil)
		if err != nil {
			return err
		}
		v, err := _FieldDesc_Read(x.Value)
		if err != nil {
			return err
		}
		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func _PrimaryKey_Read(w wire.Value) (*PrimaryKey, error) {
	var v PrimaryKey
	err := v.FromWire(w)
	return &v, err
}

func (v *EntityDefinition) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x EntityName
				x, err = _EntityName_Read(field.Value)
				v.Name = &x
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TMap {
				v.FieldDescs, err = _Map_String_FieldDesc_Read(field.Value.GetMap())
				if err != nil {
					return err
				}
			}
		case 3:
			if field.Value.Type() == wire.TStruct {
				v.PrimaryKey, err = _PrimaryKey_Read(field.Value)
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *EntityDefinition) String() string {
	if v == nil {
		return "<nil>"
	}
	var fields [3]string
	i := 0
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}
	if v.FieldDescs != nil {
		fields[i] = fmt.Sprintf("FieldDescs: %v", v.FieldDescs)
		i++
	}
	if v.PrimaryKey != nil {
		fields[i] = fmt.Sprintf("PrimaryKey: %v", v.PrimaryKey)
		i++
	}
	return fmt.Sprintf("EntityDefinition{%v}", strings.Join(fields[:i], ", "))
}

func _EntityName_EqualsPtr(lhs, rhs *EntityName) bool {
	if lhs != nil && rhs != nil {
		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _Map_String_FieldDesc_EqualsHashable(lhs, rhs map[string]*FieldDesc) bool {
	if len(lhs) != len(rhs) {
		return false
	}
	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !lv.Equals(rv) {
			return false
		}
	}
	return true
}

func (v *EntityDefinition) Equals(rhs *EntityDefinition) bool {
	if !_EntityName_EqualsPtr(v.Name, rhs.Name) {
		return false
	}
	if !((v.FieldDescs == nil && rhs.FieldDescs == nil) || (v.FieldDescs != nil && rhs.FieldDescs != nil && _Map_String_FieldDesc_EqualsHashable(v.FieldDescs, rhs.FieldDescs))) {
		return false
	}
	if !((v.PrimaryKey == nil && rhs.PrimaryKey == nil) || (v.PrimaryKey != nil && rhs.PrimaryKey != nil && v.PrimaryKey.Equals(rhs.PrimaryKey))) {
		return false
	}
	return true
}

type EntityName string

func (v EntityName) ToWire() (wire.Value, error) {
	x := (string)(v)
	return wire.NewValueString(x), error(nil)
}

func (v EntityName) String() string {
	x := (string)(v)
	return fmt.Sprint(x)
}

func (v *EntityName) FromWire(w wire.Value) error {
	x, err := w.GetString(), error(nil)
	*v = (EntityName)(x)
	return err
}

func (lhs EntityName) Equals(rhs EntityName) bool {
	return (lhs == rhs)
}

type EntityOrError struct {
	EntityValues FieldValueMap `json:"entityValues"`
	Error        *Error        `json:"error,omitempty"`
}

func (v *EntityOrError) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.EntityValues != nil {
		w, err = v.EntityValues.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Error != nil {
		w, err = v.Error.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if i != 1 {
		return wire.Value{}, fmt.Errorf("EntityOrError should have exactly one field: got %v fields", i)
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Error_Read(w wire.Value) (*Error, error) {
	var v Error
	err := v.FromWire(w)
	return &v, err
}

func (v *EntityOrError) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TMap {
				v.EntityValues, err = _FieldValueMap_Read(field.Value)
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.Error, err = _Error_Read(field.Value)
				if err != nil {
					return err
				}
			}
		}
	}
	count := 0
	if v.EntityValues != nil {
		count++
	}
	if v.Error != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("EntityOrError should have exactly one field: got %v fields", count)
	}
	return nil
}

func (v *EntityOrError) String() string {
	if v == nil {
		return "<nil>"
	}
	var fields [2]string
	i := 0
	if v.EntityValues != nil {
		fields[i] = fmt.Sprintf("EntityValues: %v", v.EntityValues)
		i++
	}
	if v.Error != nil {
		fields[i] = fmt.Sprintf("Error: %v", v.Error)
		i++
	}
	return fmt.Sprintf("EntityOrError{%v}", strings.Join(fields[:i], ", "))
}

func (v *EntityOrError) Equals(rhs *EntityOrError) bool {
	if !((v.EntityValues == nil && rhs.EntityValues == nil) || (v.EntityValues != nil && rhs.EntityValues != nil && v.EntityValues.Equals(rhs.EntityValues))) {
		return false
	}
	if !((v.Error == nil && rhs.Error == nil) || (v.Error != nil && rhs.Error != nil && v.Error.Equals(rhs.Error))) {
		return false
	}
	return true
}

type Error struct {
	ErrCode     *int32  `json:"errCode,omitempty"`
	Msg         *string `json:"msg,omitempty"`
	ShouldRetry *bool   `json:"shouldRetry,omitempty"`
}

func (v *Error) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.ErrCode != nil {
		w, err = wire.NewValueI32(*(v.ErrCode)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Msg != nil {
		w, err = wire.NewValueString(*(v.Msg)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.ShouldRetry != nil {
		w, err = wire.NewValueBool(*(v.ShouldRetry)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *Error) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.ErrCode = &x
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Msg = &x
				if err != nil {
					return err
				}
			}
		case 3:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.ShouldRetry = &x
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *Error) String() string {
	if v == nil {
		return "<nil>"
	}
	var fields [3]string
	i := 0
	if v.ErrCode != nil {
		fields[i] = fmt.Sprintf("ErrCode: %v", *(v.ErrCode))
		i++
	}
	if v.Msg != nil {
		fields[i] = fmt.Sprintf("Msg: %v", *(v.Msg))
		i++
	}
	if v.ShouldRetry != nil {
		fields[i] = fmt.Sprintf("ShouldRetry: %v", *(v.ShouldRetry))
		i++
	}
	return fmt.Sprintf("Error{%v}", strings.Join(fields[:i], ", "))
}

func (v *Error) Equals(rhs *Error) bool {
	if !_i32_EqualsPtr(v.ErrCode, rhs.ErrCode) {
		return false
	}
	if !_string_EqualsPtr(v.Msg, rhs.Msg) {
		return false
	}
	if !_bool_EqualsPtr(v.ShouldRetry, rhs.ShouldRetry) {
		return false
	}
	return true
}

type Field struct {
	Name  *string `json:"name,omitempty"`
	Value *Value  `json:"value,omitempty"`
}

func (v *Field) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Name != nil {
		w, err = wire.NewValueString(*(v.Name)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Value != nil {
		w, err = v.Value.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Value_Read(w wire.Value) (*Value, error) {
	var v Value
	err := v.FromWire(w)
	return &v, err
}

func (v *Field) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Name = &x
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.Value, err = _Value_Read(field.Value)
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *Field) String() string {
	if v == nil {
		return "<nil>"
	}
	var fields [2]string
	i := 0
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}
	if v.Value != nil {
		fields[i] = fmt.Sprintf("Value: %v", v.Value)
		i++
	}
	return fmt.Sprintf("Field{%v}", strings.Join(fields[:i], ", "))
}

func (v *Field) Equals(rhs *Field) bool {
	if !_string_EqualsPtr(v.Name, rhs.Name) {
		return false
	}
	if !((v.Value == nil && rhs.Value == nil) || (v.Value != nil && rhs.Value != nil && v.Value.Equals(rhs.Value))) {
		return false
	}
	return true
}

type FieldDesc struct {
	Type *ElemType   `json:"type,omitempty"`
	Tags []*FieldTag `json:"tags"`
}

type _Set_FieldTag_ValueList []*FieldTag

func (v _Set_FieldTag_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		if x == nil {
			return fmt.Errorf("invalid set item: value is nil")
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_FieldTag_ValueList) Size() int {
	return len(v)
}

func (_Set_FieldTag_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Set_FieldTag_ValueList) Close() {
}

func (v *FieldDesc) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Type != nil {
		w, err = v.Type.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Tags != nil {
		w, err = wire.NewValueSet(_Set_FieldTag_ValueList(v.Tags)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _ElemType_Read(w wire.Value) (ElemType, error) {
	var v ElemType
	err := v.FromWire(w)
	return v, err
}

func _FieldTag_Read(w wire.Value) (*FieldTag, error) {
	var v FieldTag
	err := v.FromWire(w)
	return &v, err
}

func _Set_FieldTag_Read(s wire.ValueList) ([]*FieldTag, error) {
	if s.ValueType() != wire.TStruct {
		return nil, nil
	}
	o := make([]*FieldTag, 0, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := _FieldTag_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	s.Close()
	return o, err
}

func (v *FieldDesc) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x ElemType
				x, err = _ElemType_Read(field.Value)
				v.Type = &x
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TSet {
				v.Tags, err = _Set_FieldTag_Read(field.Value.GetSet())
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *FieldDesc) String() string {
	if v == nil {
		return "<nil>"
	}
	var fields [2]string
	i := 0
	if v.Type != nil {
		fields[i] = fmt.Sprintf("Type: %v", *(v.Type))
		i++
	}
	if v.Tags != nil {
		fields[i] = fmt.Sprintf("Tags: %v", v.Tags)
		i++
	}
	return fmt.Sprintf("FieldDesc{%v}", strings.Join(fields[:i], ", "))
}

func _ElemType_EqualsPtr(lhs, rhs *ElemType) bool {
	if lhs != nil && rhs != nil {
		x := *lhs
		y := *rhs
		return x.Equals(y)
	}
	return lhs == nil && rhs == nil
}

func _Set_FieldTag_Equals(lhs, rhs []*FieldTag) bool {
	if len(lhs) != len(rhs) {
		return false
	}
	for _, x := range lhs {
		ok := false
		for _, y := range rhs {
			if x.Equals(y) {
				ok = true
				break
			}
		}
		if !ok {
			return false
		}
	}
	return true
}

func (v *FieldDesc) Equals(rhs *FieldDesc) bool {
	if !_ElemType_EqualsPtr(v.Type, rhs.Type) {
		return false
	}
	if !((v.Tags == nil && rhs.Tags == nil) || (v.Tags != nil && rhs.Tags != nil && _Set_FieldTag_Equals(v.Tags, rhs.Tags))) {
		return false
	}
	return true
}

type FieldTag struct {
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

func (v *FieldTag) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Name != nil {
		w, err = wire.NewValueString(*(v.Name)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Value != nil {
		w, err = wire.NewValueString(*(v.Value)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *FieldTag) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Name = &x
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Value = &x
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *FieldTag) String() string {
	if v == nil {
		return "<nil>"
	}
	var fields [2]string
	i := 0
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}
	if v.Value != nil {
		fields[i] = fmt.Sprintf("Value: %v", *(v.Value))
		i++
	}
	return fmt.Sprintf("FieldTag{%v}", strings.Join(fields[:i], ", "))
}

func (v *FieldTag) Equals(rhs *FieldTag) bool {
	if !_string_EqualsPtr(v.Name, rhs.Name) {
		return false
	}
	if !_string_EqualsPtr(v.Value, rhs.Value) {
		return false
	}
	return true
}

type _Map_String_Value_MapItemList map[string]*Value

func (m _Map_String_Value_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := wire.NewValueString(k), error(nil)
		if err != nil {
			return err
		}
		vw, err := v.ToWire()
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_String_Value_MapItemList) Size() int {
	return len(m)
}

func (_Map_String_Value_MapItemList) KeyType() wire.Type {
	return wire.TBinary
}

func (_Map_String_Value_MapItemList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Map_String_Value_MapItemList) Close() {
}

func _Map_String_Value_Read(m wire.MapItemList) (map[string]*Value, error) {
	if m.KeyType() != wire.TBinary {
		return nil, nil
	}
	if m.ValueType() != wire.TStruct {
		return nil, nil
	}
	o := make(map[string]*Value, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetString(), error(nil)
		if err != nil {
			return err
		}
		v, err := _Value_Read(x.Value)
		if err != nil {
			return err
		}
		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func _Map_String_Value_EqualsHashable(lhs, rhs map[string]*Value) bool {
	if len(lhs) != len(rhs) {
		return false
	}
	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !lv.Equals(rv) {
			return false
		}
	}
	return true
}

type FieldValueMap map[string]*Value

func (v FieldValueMap) ToWire() (wire.Value, error) {
	x := (map[string]*Value)(v)
	return wire.NewValueMap(_Map_String_Value_MapItemList(x)), error(nil)
}

func (v FieldValueMap) String() string {
	x := (map[string]*Value)(v)
	return fmt.Sprint(x)
}

func (v *FieldValueMap) FromWire(w wire.Value) error {
	x, err := _Map_String_Value_Read(w.GetMap())
	*v = (FieldValueMap)(x)
	return err
}

func (lhs FieldValueMap) Equals(rhs FieldValueMap) bool {
	return _Map_String_Value_EqualsHashable(lhs, rhs)
}

type InternalServerError struct {
	Err       string  `json:"err"`
	Message   *string `json:"message,omitempty"`
	ErrorCode *int32  `json:"errorCode,omitempty"`
}

func (v *InternalServerError) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	w, err = wire.NewValueString(v.Err), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.Message != nil {
		w, err = wire.NewValueString(*(v.Message)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.ErrorCode != nil {
		w, err = wire.NewValueI32(*(v.ErrorCode)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *InternalServerError) FromWire(w wire.Value) error {
	var err error
	errIsSet := false
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.Err, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				errIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Message = &x
				if err != nil {
					return err
				}
			}
		case 3:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.ErrorCode = &x
				if err != nil {
					return err
				}
			}
		}
	}
	if !errIsSet {
		return errors.New("field Err of InternalServerError is required")
	}
	return nil
}

func (v *InternalServerError) String() string {
	if v == nil {
		return "<nil>"
	}
	var fields [3]string
	i := 0
	fields[i] = fmt.Sprintf("Err: %v", v.Err)
	i++
	if v.Message != nil {
		fields[i] = fmt.Sprintf("Message: %v", *(v.Message))
		i++
	}
	if v.ErrorCode != nil {
		fields[i] = fmt.Sprintf("ErrorCode: %v", *(v.ErrorCode))
		i++
	}
	return fmt.Sprintf("InternalServerError{%v}", strings.Join(fields[:i], ", "))
}

func (v *InternalServerError) Equals(rhs *InternalServerError) bool {
	if !(v.Err == rhs.Err) {
		return false
	}
	if !_string_EqualsPtr(v.Message, rhs.Message) {
		return false
	}
	if !_i32_EqualsPtr(v.ErrorCode, rhs.ErrorCode) {
		return false
	}
	return true
}

func (v *InternalServerError) Error() string {
	return v.String()
}

type NamePrefix string

func (v NamePrefix) ToWire() (wire.Value, error) {
	x := (string)(v)
	return wire.NewValueString(x), error(nil)
}

func (v NamePrefix) String() string {
	x := (string)(v)
	return fmt.Sprint(x)
}

func (v *NamePrefix) FromWire(w wire.Value) error {
	x, err := w.GetString(), error(nil)
	*v = (NamePrefix)(x)
	return err
}

func (lhs NamePrefix) Equals(rhs NamePrefix) bool {
	return (lhs == rhs)
}

type Operator int32

const (
	OperatorEq     Operator = 0
	OperatorLt     Operator = 1
	OperatorGt     Operator = 2
	OperatorLtOrEq Operator = 3
	OperatorGtOrEq Operator = 4
)

func (v Operator) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

func (v *Operator) FromWire(w wire.Value) error {
	*v = (Operator)(w.GetI32())
	return nil
}

func (v Operator) String() string {
	w := int32(v)
	switch w {
	case 0:
		return "EQ"
	case 1:
		return "LT"
	case 2:
		return "GT"
	case 3:
		return "LT_OR_EQ"
	case 4:
		return "GT_OR_EQ"
	}
	return fmt.Sprintf("Operator(%d)", w)
}

func (v Operator) Equals(rhs Operator) bool {
	return v == rhs
}

func (v Operator) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 0:
		return ([]byte)("\"EQ\""), nil
	case 1:
		return ([]byte)("\"LT\""), nil
	case 2:
		return ([]byte)("\"GT\""), nil
	case 3:
		return ([]byte)("\"LT_OR_EQ\""), nil
	case 4:
		return ([]byte)("\"GT_OR_EQ\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

func (v *Operator) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}
	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "Operator")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "Operator")
		}
		*v = (Operator)(x)
		return nil
	case string:
		switch w {
		case "EQ":
			*v = OperatorEq
			return nil
		case "LT":
			*v = OperatorLt
			return nil
		case "GT":
			*v = OperatorGt
			return nil
		case "LT_OR_EQ":
			*v = OperatorLtOrEq
			return nil
		case "GT_OR_EQ":
			*v = OperatorGtOrEq
			return nil
		default:
			return fmt.Errorf("unknown enum value %q for %q", w, "Operator")
		}
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "Operator")
	}
}

type PrimaryKey struct {
	PartitionKeys  []string         `json:"partitionKeys"`
	ClusteringKeys []*ClusteringKey `json:"clusteringKeys"`
}

type _List_String_ValueList []string

func (v _List_String_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		w, err := wire.NewValueString(x), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_String_ValueList) Size() int {
	return len(v)
}

func (_List_String_ValueList) ValueType() wire.Type {
	return wire.TBinary
}

func (_List_String_ValueList) Close() {
}

type _List_ClusteringKey_ValueList []*ClusteringKey

func (v _List_ClusteringKey_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_ClusteringKey_ValueList) Size() int {
	return len(v)
}

func (_List_ClusteringKey_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_List_ClusteringKey_ValueList) Close() {
}

func (v *PrimaryKey) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.PartitionKeys != nil {
		w, err = wire.NewValueList(_List_String_ValueList(v.PartitionKeys)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.ClusteringKeys != nil {
		w, err = wire.NewValueList(_List_ClusteringKey_ValueList(v.ClusteringKeys)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _List_String_Read(l wire.ValueList) ([]string, error) {
	if l.ValueType() != wire.TBinary {
		return nil, nil
	}
	o := make([]string, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := x.GetString(), error(nil)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func _ClusteringKey_Read(w wire.Value) (*ClusteringKey, error) {
	var v ClusteringKey
	err := v.FromWire(w)
	return &v, err
}

func _List_ClusteringKey_Read(l wire.ValueList) ([]*ClusteringKey, error) {
	if l.ValueType() != wire.TStruct {
		return nil, nil
	}
	o := make([]*ClusteringKey, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _ClusteringKey_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func (v *PrimaryKey) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.PartitionKeys, err = _List_String_Read(field.Value.GetList())
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TList {
				v.ClusteringKeys, err = _List_ClusteringKey_Read(field.Value.GetList())
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *PrimaryKey) String() string {
	if v == nil {
		return "<nil>"
	}
	var fields [2]string
	i := 0
	if v.PartitionKeys != nil {
		fields[i] = fmt.Sprintf("PartitionKeys: %v", v.PartitionKeys)
		i++
	}
	if v.ClusteringKeys != nil {
		fields[i] = fmt.Sprintf("ClusteringKeys: %v", v.ClusteringKeys)
		i++
	}
	return fmt.Sprintf("PrimaryKey{%v}", strings.Join(fields[:i], ", "))
}

func _List_String_Equals(lhs, rhs []string) bool {
	if len(lhs) != len(rhs) {
		return false
	}
	for i, lv := range lhs {
		rv := rhs[i]
		if !(lv == rv) {
			return false
		}
	}
	return true
}

func _List_ClusteringKey_Equals(lhs, rhs []*ClusteringKey) bool {
	if len(lhs) != len(rhs) {
		return false
	}
	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}
	return true
}

func (v *PrimaryKey) Equals(rhs *PrimaryKey) bool {
	if !((v.PartitionKeys == nil && rhs.PartitionKeys == nil) || (v.PartitionKeys != nil && rhs.PartitionKeys != nil && _List_String_Equals(v.PartitionKeys, rhs.PartitionKeys))) {
		return false
	}
	if !((v.ClusteringKeys == nil && rhs.ClusteringKeys == nil) || (v.ClusteringKeys != nil && rhs.ClusteringKeys != nil && _List_ClusteringKey_Equals(v.ClusteringKeys, rhs.ClusteringKeys))) {
		return false
	}
	return true
}

type RangeRequest struct {
	Ref          *SchemaRef          `json:"ref,omitempty"`
	Token        *Token              `json:"token,omitempty"`
	Limit        *int32              `json:"limit,omitempty"`
	Conditions   []*Condition        `json:"conditions"`
	FieldsToRead map[string]struct{} `json:"fieldsToRead"`
}

type _List_Condition_ValueList []*Condition

func (v _List_Condition_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Condition_ValueList) Size() int {
	return len(v)
}

func (_List_Condition_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_List_Condition_ValueList) Close() {
}

func (v *RangeRequest) ToWire() (wire.Value, error) {
	var (
		fields [5]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Ref != nil {
		w, err = v.Ref.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Token != nil {
		w, err = v.Token.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Limit != nil {
		w, err = wire.NewValueI32(*(v.Limit)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.Conditions != nil {
		w, err = wire.NewValueList(_List_Condition_ValueList(v.Conditions)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.FieldsToRead != nil {
		w, err = wire.NewValueSet(_Set_String_ValueList(v.FieldsToRead)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Token_Read(w wire.Value) (Token, error) {
	var x Token
	err := x.FromWire(w)
	return x, err
}

func _Condition_Read(w wire.Value) (*Condition, error) {
	var v Condition
	err := v.FromWire(w)
	return &v, err
}

func _List_Condition_Read(l wire.ValueList) ([]*Condition, error) {
	if l.ValueType() != wire.TStruct {
		return nil, nil
	}
	o := make([]*Condition, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _Condition_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func (v *RangeRequest) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Ref, err = _SchemaRef_Read(field.Value)
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x Token
				x, err = _Token_Read(field.Value)
				v.Token = &x
				if err != nil {
					return err
				}
			}
		case 3:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Limit = &x
				if err != nil {
					return err
				}
			}
		case 4:
			if field.Value.Type() == wire.TList {
				v.Conditions, err = _List_Condition_Read(field.Value.GetList())
				if err != nil {
					return err
				}
			}
		case 5:
			if field.Value.Type() == wire.TSet {
				v.FieldsToRead, err = _Set_String_Read(field.Value.GetSet())
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *RangeRequest) String() string {
	if v == nil {
		return "<nil>"
	}
	var fields [5]string
	i := 0
	if v.Ref != nil {
		fields[i] = fmt.Sprintf("Ref: %v", v.Ref)
		i++
	}
	if v.Token != nil {
		fields[i] = fmt.Sprintf("Token: %v", *(v.Token))
		i++
	}
	if v.Limit != nil {
		fields[i] = fmt.Sprintf("Limit: %v", *(v.Limit))
		i++
	}
	if v.Conditions != nil {
		fields[i] = fmt.Sprintf("Conditions: %v", v.Conditions)
		i++
	}
	if v.FieldsToRead != nil {
		fields[i] = fmt.Sprintf("FieldsToRead: %v", v.FieldsToRead)
		i++
	}
	return fmt.Sprintf("RangeRequest{%v}", strings.Join(fields[:i], ", "))
}

func _Token_EqualsPtr(lhs, rhs *Token) bool {
	if lhs != nil && rhs != nil {
		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _List_Condition_Equals(lhs, rhs []*Condition) bool {
	if len(lhs) != len(rhs) {
		return false
	}
	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}
	return true
}

func (v *RangeRequest) Equals(rhs *RangeRequest) bool {
	if !((v.Ref == nil && rhs.Ref == nil) || (v.Ref != nil && rhs.Ref != nil && v.Ref.Equals(rhs.Ref))) {
		return false
	}
	if !_Token_EqualsPtr(v.Token, rhs.Token) {
		return false
	}
	if !_i32_EqualsPtr(v.Limit, rhs.Limit) {
		return false
	}
	if !((v.Conditions == nil && rhs.Conditions == nil) || (v.Conditions != nil && rhs.Conditions != nil && _List_Condition_Equals(v.Conditions, rhs.Conditions))) {
		return false
	}
	if !((v.FieldsToRead == nil && rhs.FieldsToRead == nil) || (v.FieldsToRead != nil && rhs.FieldsToRead != nil && _Set_String_Equals(v.FieldsToRead, rhs.FieldsToRead))) {
		return false
	}
	return true
}

type RangeResponse struct {
	Entities  []FieldValueMap `json:"entities"`
	NextToken *Token          `json:"nextToken,omitempty"`
}

func (v *RangeResponse) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Entities != nil {
		w, err = wire.NewValueList(_List_FieldValueMap_ValueList(v.Entities)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.NextToken != nil {
		w, err = v.NextToken.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *RangeResponse) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.Entities, err = _List_FieldValueMap_Read(field.Value.GetList())
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x Token
				x, err = _Token_Read(field.Value)
				v.NextToken = &x
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *RangeResponse) String() string {
	if v == nil {
		return "<nil>"
	}
	var fields [2]string
	i := 0
	if v.Entities != nil {
		fields[i] = fmt.Sprintf("Entities: %v", v.Entities)
		i++
	}
	if v.NextToken != nil {
		fields[i] = fmt.Sprintf("NextToken: %v", *(v.NextToken))
		i++
	}
	return fmt.Sprintf("RangeResponse{%v}", strings.Join(fields[:i], ", "))
}

func (v *RangeResponse) Equals(rhs *RangeResponse) bool {
	if !((v.Entities == nil && rhs.Entities == nil) || (v.Entities != nil && rhs.Entities != nil && _List_FieldValueMap_Equals(v.Entities, rhs.Entities))) {
		return false
	}
	if !_Token_EqualsPtr(v.NextToken, rhs.NextToken) {
		return false
	}
	return true
}

type RawValue struct {
	BinaryValue []byte   `json:"binaryValue"`
	BoolValue   *bool    `json:"boolValue,omitempty"`
	DoubleValue *float64 `json:"doubleValue,omitempty"`
	Int32Value  *int32   `json:"int32Value,omitempty"`
	Int64Value  *int64   `json:"int64Value,omitempty"`
	StringValue *string  `json:"stringValue,omitempty"`
}

func (v *RawValue) ToWire() (wire.Value, error) {
	var (
		fields [6]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.BinaryValue != nil {
		w, err = wire.NewValueBinary(v.BinaryValue), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.BoolValue != nil {
		w, err = wire.NewValueBool(*(v.BoolValue)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.DoubleValue != nil {
		w, err = wire.NewValueDouble(*(v.DoubleValue)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.Int32Value != nil {
		w, err = wire.NewValueI32(*(v.Int32Value)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.Int64Value != nil {
		w, err = wire.NewValueI64(*(v.Int64Value)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}
	if v.StringValue != nil {
		w, err = wire.NewValueString(*(v.StringValue)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 6, Value: w}
		i++
	}
	if i != 1 {
		return wire.Value{}, fmt.Errorf("RawValue should have exactly one field: got %v fields", i)
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *RawValue) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.BinaryValue, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.BoolValue = &x
				if err != nil {
					return err
				}
			}
		case 3:
			if field.Value.Type() == wire.TDouble {
				var x float64
				x, err = field.Value.GetDouble(), error(nil)
				v.DoubleValue = &x
				if err != nil {
					return err
				}
			}
		case 4:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Int32Value = &x
				if err != nil {
					return err
				}
			}
		case 5:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.Int64Value = &x
				if err != nil {
					return err
				}
			}
		case 6:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.StringValue = &x
				if err != nil {
					return err
				}
			}
		}
	}
	count := 0
	if v.BinaryValue != nil {
		count++
	}
	if v.BoolValue != nil {
		count++
	}
	if v.DoubleValue != nil {
		count++
	}
	if v.Int32Value != nil {
		count++
	}
	if v.Int64Value != nil {
		count++
	}
	if v.StringValue != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("RawValue should have exactly one field: got %v fields", count)
	}
	return nil
}

func (v *RawValue) String() string {
	if v == nil {
		return "<nil>"
	}
	var fields [6]string
	i := 0
	if v.BinaryValue != nil {
		fields[i] = fmt.Sprintf("BinaryValue: %v", v.BinaryValue)
		i++
	}
	if v.BoolValue != nil {
		fields[i] = fmt.Sprintf("BoolValue: %v", *(v.BoolValue))
		i++
	}
	if v.DoubleValue != nil {
		fields[i] = fmt.Sprintf("DoubleValue: %v", *(v.DoubleValue))
		i++
	}
	if v.Int32Value != nil {
		fields[i] = fmt.Sprintf("Int32Value: %v", *(v.Int32Value))
		i++
	}
	if v.Int64Value != nil {
		fields[i] = fmt.Sprintf("Int64Value: %v", *(v.Int64Value))
		i++
	}
	if v.StringValue != nil {
		fields[i] = fmt.Sprintf("StringValue: %v", *(v.StringValue))
		i++
	}
	return fmt.Sprintf("RawValue{%v}", strings.Join(fields[:i], ", "))
}

func _double_EqualsPtr(lhs, rhs *float64) bool {
	if lhs != nil && rhs != nil {
		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _i64_EqualsPtr(lhs, rhs *int64) bool {
	if lhs != nil && rhs != nil {
		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func (v *RawValue) Equals(rhs *RawValue) bool {
	if !((v.BinaryValue == nil && rhs.BinaryValue == nil) || (v.BinaryValue != nil && rhs.BinaryValue != nil && bytes.Equal(v.BinaryValue, rhs.BinaryValue))) {
		return false
	}
	if !_bool_EqualsPtr(v.BoolValue, rhs.BoolValue) {
		return false
	}
	if !_double_EqualsPtr(v.DoubleValue, rhs.DoubleValue) {
		return false
	}
	if !_i32_EqualsPtr(v.Int32Value, rhs.Int32Value) {
		return false
	}
	if !_i64_EqualsPtr(v.Int64Value, rhs.Int64Value) {
		return false
	}
	if !_string_EqualsPtr(v.StringValue, rhs.StringValue) {
		return false
	}
	return true
}

type ReadRequest struct {
	Ref          *SchemaRef          `json:"ref,omitempty"`
	KeyValues    FieldValueMap       `json:"keyValues"`
	FieldsToRead map[string]struct{} `json:"fieldsToRead"`
}

func (v *ReadRequest) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Ref != nil {
		w, err = v.Ref.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.KeyValues != nil {
		w, err = v.KeyValues.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.FieldsToRead != nil {
		w, err = wire.NewValueSet(_Set_String_ValueList(v.FieldsToRead)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *ReadRequest) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Ref, err = _SchemaRef_Read(field.Value)
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TMap {
				v.KeyValues, err = _FieldValueMap_Read(field.Value)
				if err != nil {
					return err
				}
			}
		case 3:
			if field.Value.Type() == wire.TSet {
				v.FieldsToRead, err = _Set_String_Read(field.Value.GetSet())
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *ReadRequest) String() string {
	if v == nil {
		return "<nil>"
	}
	var fields [3]string
	i := 0
	if v.Ref != nil {
		fields[i] = fmt.Sprintf("Ref: %v", v.Ref)
		i++
	}
	if v.KeyValues != nil {
		fields[i] = fmt.Sprintf("KeyValues: %v", v.KeyValues)
		i++
	}
	if v.FieldsToRead != nil {
		fields[i] = fmt.Sprintf("FieldsToRead: %v", v.FieldsToRead)
		i++
	}
	return fmt.Sprintf("ReadRequest{%v}", strings.Join(fields[:i], ", "))
}

func (v *ReadRequest) Equals(rhs *ReadRequest) bool {
	if !((v.Ref == nil && rhs.Ref == nil) || (v.Ref != nil && rhs.Ref != nil && v.Ref.Equals(rhs.Ref))) {
		return false
	}
	if !((v.KeyValues == nil && rhs.KeyValues == nil) || (v.KeyValues != nil && rhs.KeyValues != nil && v.KeyValues.Equals(rhs.KeyValues))) {
		return false
	}
	if !((v.FieldsToRead == nil && rhs.FieldsToRead == nil) || (v.FieldsToRead != nil && rhs.FieldsToRead != nil && _Set_String_Equals(v.FieldsToRead, rhs.FieldsToRead))) {
		return false
	}
	return true
}

type ReadResponse struct {
	EntityValues FieldValueMap `json:"entityValues"`
}

func (v *ReadResponse) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.EntityValues != nil {
		w, err = v.EntityValues.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *ReadResponse) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TMap {
				v.EntityValues, err = _FieldValueMap_Read(field.Value)
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *ReadResponse) String() string {
	if v == nil {
		return "<nil>"
	}
	var fields [1]string
	i := 0
	if v.EntityValues != nil {
		fields[i] = fmt.Sprintf("EntityValues: %v", v.EntityValues)
		i++
	}
	return fmt.Sprintf("ReadResponse{%v}", strings.Join(fields[:i], ", "))
}

func (v *ReadResponse) Equals(rhs *ReadResponse) bool {
	if !((v.EntityValues == nil && rhs.EntityValues == nil) || (v.EntityValues != nil && rhs.EntityValues != nil && v.EntityValues.Equals(rhs.EntityValues))) {
		return false
	}
	return true
}

type RemoveRequest struct {
	Ref       *SchemaRef    `json:"ref,omitempty"`
	KeyValues FieldValueMap `json:"keyValues"`
}

func (v *RemoveRequest) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Ref != nil {
		w, err = v.Ref.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.KeyValues != nil {
		w, err = v.KeyValues.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *RemoveRequest) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Ref, err = _SchemaRef_Read(field.Value)
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TMap {
				v.KeyValues, err = _FieldValueMap_Read(field.Value)
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *RemoveRequest) String() string {
	if v == nil {
		return "<nil>"
	}
	var fields [2]string
	i := 0
	if v.Ref != nil {
		fields[i] = fmt.Sprintf("Ref: %v", v.Ref)
		i++
	}
	if v.KeyValues != nil {
		fields[i] = fmt.Sprintf("KeyValues: %v", v.KeyValues)
		i++
	}
	return fmt.Sprintf("RemoveRequest{%v}", strings.Join(fields[:i], ", "))
}

func (v *RemoveRequest) Equals(rhs *RemoveRequest) bool {
	if !((v.Ref == nil && rhs.Ref == nil) || (v.Ref != nil && rhs.Ref != nil && v.Ref.Equals(rhs.Ref))) {
		return false
	}
	if !((v.KeyValues == nil && rhs.KeyValues == nil) || (v.KeyValues != nil && rhs.KeyValues != nil && v.KeyValues.Equals(rhs.KeyValues))) {
		return false
	}
	return true
}

type ScanRequest struct {
	Ref          *SchemaRef          `json:"ref,omitempty"`
	Token        *Token              `json:"token,omitempty"`
	Limit        *int32              `json:"limit,omitempty"`
	FieldsToRead map[string]struct{} `json:"fieldsToRead"`
}

func (v *ScanRequest) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Ref != nil {
		w, err = v.Ref.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Token != nil {
		w, err = v.Token.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Limit != nil {
		w, err = wire.NewValueI32(*(v.Limit)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.FieldsToRead != nil {
		w, err = wire.NewValueSet(_Set_String_ValueList(v.FieldsToRead)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *ScanRequest) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Ref, err = _SchemaRef_Read(field.Value)
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x Token
				x, err = _Token_Read(field.Value)
				v.Token = &x
				if err != nil {
					return err
				}
			}
		case 3:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Limit = &x
				if err != nil {
					return err
				}
			}
		case 4:
			if field.Value.Type() == wire.TSet {
				v.FieldsToRead, err = _Set_String_Read(field.Value.GetSet())
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *ScanRequest) String() string {
	if v == nil {
		return "<nil>"
	}
	var fields [4]string
	i := 0
	if v.Ref != nil {
		fields[i] = fmt.Sprintf("Ref: %v", v.Ref)
		i++
	}
	if v.Token != nil {
		fields[i] = fmt.Sprintf("Token: %v", *(v.Token))
		i++
	}
	if v.Limit != nil {
		fields[i] = fmt.Sprintf("Limit: %v", *(v.Limit))
		i++
	}
	if v.FieldsToRead != nil {
		fields[i] = fmt.Sprintf("FieldsToRead: %v", v.FieldsToRead)
		i++
	}
	return fmt.Sprintf("ScanRequest{%v}", strings.Join(fields[:i], ", "))
}

func (v *ScanRequest) Equals(rhs *ScanRequest) bool {
	if !((v.Ref == nil && rhs.Ref == nil) || (v.Ref != nil && rhs.Ref != nil && v.Ref.Equals(rhs.Ref))) {
		return false
	}
	if !_Token_EqualsPtr(v.Token, rhs.Token) {
		return false
	}
	if !_i32_EqualsPtr(v.Limit, rhs.Limit) {
		return false
	}
	if !((v.FieldsToRead == nil && rhs.FieldsToRead == nil) || (v.FieldsToRead != nil && rhs.FieldsToRead != nil && _Set_String_Equals(v.FieldsToRead, rhs.FieldsToRead))) {
		return false
	}
	return true
}

type ScanResponse struct {
	Entities  []FieldValueMap `json:"entities"`
	NextToken *Token          `json:"nextToken,omitempty"`
}

func (v *ScanResponse) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Entities != nil {
		w, err = wire.NewValueList(_List_FieldValueMap_ValueList(v.Entities)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.NextToken != nil {
		w, err = v.NextToken.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *ScanResponse) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.Entities, err = _List_FieldValueMap_Read(field.Value.GetList())
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x Token
				x, err = _Token_Read(field.Value)
				v.NextToken = &x
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *ScanResponse) String() string {
	if v == nil {
		return "<nil>"
	}
	var fields [2]string
	i := 0
	if v.Entities != nil {
		fields[i] = fmt.Sprintf("Entities: %v", v.Entities)
		i++
	}
	if v.NextToken != nil {
		fields[i] = fmt.Sprintf("NextToken: %v", *(v.NextToken))
		i++
	}
	return fmt.Sprintf("ScanResponse{%v}", strings.Join(fields[:i], ", "))
}

func (v *ScanResponse) Equals(rhs *ScanResponse) bool {
	if !((v.Entities == nil && rhs.Entities == nil) || (v.Entities != nil && rhs.Entities != nil && _List_FieldValueMap_Equals(v.Entities, rhs.Entities))) {
		return false
	}
	if !_Token_EqualsPtr(v.NextToken, rhs.NextToken) {
		return false
	}
	return true
}

type SchemaRef struct {
	Scope      *Scope      `json:"scope,omitempty"`
	NamePrefix *NamePrefix `json:"namePrefix,omitempty"`
	EntityName *EntityName `json:"entityName,omitempty"`
	Version    *Version    `json:"version,omitempty"`
}

func (v *SchemaRef) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Scope != nil {
		w, err = v.Scope.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.NamePrefix != nil {
		w, err = v.NamePrefix.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.EntityName != nil {
		w, err = v.EntityName.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.Version != nil {
		w, err = v.Version.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *SchemaRef) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x Scope
				x, err = _Scope_Read(field.Value)
				v.Scope = &x
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x NamePrefix
				x, err = _NamePrefix_Read(field.Value)
				v.NamePrefix = &x
				if err != nil {
					return err
				}
			}
		case 3:
			if field.Value.Type() == wire.TBinary {
				var x EntityName
				x, err = _EntityName_Read(field.Value)
				v.EntityName = &x
				if err != nil {
					return err
				}
			}
		case 4:
			if field.Value.Type() == wire.TI32 {
				var x Version
				x, err = _Version_Read(field.Value)
				v.Version = &x
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *SchemaRef) String() string {
	if v == nil {
		return "<nil>"
	}
	var fields [4]string
	i := 0
	if v.Scope != nil {
		fields[i] = fmt.Sprintf("Scope: %v", *(v.Scope))
		i++
	}
	if v.NamePrefix != nil {
		fields[i] = fmt.Sprintf("NamePrefix: %v", *(v.NamePrefix))
		i++
	}
	if v.EntityName != nil {
		fields[i] = fmt.Sprintf("EntityName: %v", *(v.EntityName))
		i++
	}
	if v.Version != nil {
		fields[i] = fmt.Sprintf("Version: %v", *(v.Version))
		i++
	}
	return fmt.Sprintf("SchemaRef{%v}", strings.Join(fields[:i], ", "))
}

func _Version_EqualsPtr(lhs, rhs *Version) bool {
	if lhs != nil && rhs != nil {
		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func (v *SchemaRef) Equals(rhs *SchemaRef) bool {
	if !_Scope_EqualsPtr(v.Scope, rhs.Scope) {
		return false
	}
	if !_NamePrefix_EqualsPtr(v.NamePrefix, rhs.NamePrefix) {
		return false
	}
	if !_EntityName_EqualsPtr(v.EntityName, rhs.EntityName) {
		return false
	}
	if !_Version_EqualsPtr(v.Version, rhs.Version) {
		return false
	}
	return true
}

type Scope string

func (v Scope) ToWire() (wire.Value, error) {
	x := (string)(v)
	return wire.NewValueString(x), error(nil)
}

func (v Scope) String() string {
	x := (string)(v)
	return fmt.Sprint(x)
}

func (v *Scope) FromWire(w wire.Value) error {
	x, err := w.GetString(), error(nil)
	*v = (Scope)(x)
	return err
}

func (lhs Scope) Equals(rhs Scope) bool {
	return (lhs == rhs)
}

type SearchRequest struct {
	Ref          *SchemaRef          `json:"ref,omitempty"`
	Token        *Token              `json:"token,omitempty"`
	Limit        *int32              `json:"limit,omitempty"`
	SearchBy     *Field              `json:"searchBy,omitempty"`
	FieldsToRead map[string]struct{} `json:"fieldsToRead"`
}

func (v *SearchRequest) ToWire() (wire.Value, error) {
	var (
		fields [5]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Ref != nil {
		w, err = v.Ref.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Token != nil {
		w, err = v.Token.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Limit != nil {
		w, err = wire.NewValueI32(*(v.Limit)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.SearchBy != nil {
		w, err = v.SearchBy.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.FieldsToRead != nil {
		w, err = wire.NewValueSet(_Set_String_ValueList(v.FieldsToRead)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *SearchRequest) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Ref, err = _SchemaRef_Read(field.Value)
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x Token
				x, err = _Token_Read(field.Value)
				v.Token = &x
				if err != nil {
					return err
				}
			}
		case 3:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Limit = &x
				if err != nil {
					return err
				}
			}
		case 4:
			if field.Value.Type() == wire.TStruct {
				v.SearchBy, err = _Field_Read(field.Value)
				if err != nil {
					return err
				}
			}
		case 5:
			if field.Value.Type() == wire.TSet {
				v.FieldsToRead, err = _Set_String_Read(field.Value.GetSet())
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *SearchRequest) String() string {
	if v == nil {
		return "<nil>"
	}
	var fields [5]string
	i := 0
	if v.Ref != nil {
		fields[i] = fmt.Sprintf("Ref: %v", v.Ref)
		i++
	}
	if v.Token != nil {
		fields[i] = fmt.Sprintf("Token: %v", *(v.Token))
		i++
	}
	if v.Limit != nil {
		fields[i] = fmt.Sprintf("Limit: %v", *(v.Limit))
		i++
	}
	if v.SearchBy != nil {
		fields[i] = fmt.Sprintf("SearchBy: %v", v.SearchBy)
		i++
	}
	if v.FieldsToRead != nil {
		fields[i] = fmt.Sprintf("FieldsToRead: %v", v.FieldsToRead)
		i++
	}
	return fmt.Sprintf("SearchRequest{%v}", strings.Join(fields[:i], ", "))
}

func (v *SearchRequest) Equals(rhs *SearchRequest) bool {
	if !((v.Ref == nil && rhs.Ref == nil) || (v.Ref != nil && rhs.Ref != nil && v.Ref.Equals(rhs.Ref))) {
		return false
	}
	if !_Token_EqualsPtr(v.Token, rhs.Token) {
		return false
	}
	if !_i32_EqualsPtr(v.Limit, rhs.Limit) {
		return false
	}
	if !((v.SearchBy == nil && rhs.SearchBy == nil) || (v.SearchBy != nil && rhs.SearchBy != nil && v.SearchBy.Equals(rhs.SearchBy))) {
		return false
	}
	if !((v.FieldsToRead == nil && rhs.FieldsToRead == nil) || (v.FieldsToRead != nil && rhs.FieldsToRead != nil && _Set_String_Equals(v.FieldsToRead, rhs.FieldsToRead))) {
		return false
	}
	return true
}

type SearchResponse struct {
	Entities  []FieldValueMap `json:"entities"`
	NextToken *Token          `json:"nextToken,omitempty"`
}

func (v *SearchResponse) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Entities != nil {
		w, err = wire.NewValueList(_List_FieldValueMap_ValueList(v.Entities)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.NextToken != nil {
		w, err = v.NextToken.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *SearchResponse) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.Entities, err = _List_FieldValueMap_Read(field.Value.GetList())
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x Token
				x, err = _Token_Read(field.Value)
				v.NextToken = &x
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *SearchResponse) String() string {
	if v == nil {
		return "<nil>"
	}
	var fields [2]string
	i := 0
	if v.Entities != nil {
		fields[i] = fmt.Sprintf("Entities: %v", v.Entities)
		i++
	}
	if v.NextToken != nil {
		fields[i] = fmt.Sprintf("NextToken: %v", *(v.NextToken))
		i++
	}
	return fmt.Sprintf("SearchResponse{%v}", strings.Join(fields[:i], ", "))
}

func (v *SearchResponse) Equals(rhs *SearchResponse) bool {
	if !((v.Entities == nil && rhs.Entities == nil) || (v.Entities != nil && rhs.Entities != nil && _List_FieldValueMap_Equals(v.Entities, rhs.Entities))) {
		return false
	}
	if !_Token_EqualsPtr(v.NextToken, rhs.NextToken) {
		return false
	}
	return true
}

type Token string

func (v Token) ToWire() (wire.Value, error) {
	x := (string)(v)
	return wire.NewValueString(x), error(nil)
}

func (v Token) String() string {
	x := (string)(v)
	return fmt.Sprint(x)
}

func (v *Token) FromWire(w wire.Value) error {
	x, err := w.GetString(), error(nil)
	*v = (Token)(x)
	return err
}

func (lhs Token) Equals(rhs Token) bool {
	return (lhs == rhs)
}

type TruncateScopeRequest struct {
	Name *Scope `json:"name,omitempty"`
}

func (v *TruncateScopeRequest) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Name != nil {
		w, err = v.Name.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *TruncateScopeRequest) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x Scope
				x, err = _Scope_Read(field.Value)
				v.Name = &x
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *TruncateScopeRequest) String() string {
	if v == nil {
		return "<nil>"
	}
	var fields [1]string
	i := 0
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}
	return fmt.Sprintf("TruncateScopeRequest{%v}", strings.Join(fields[:i], ", "))
}

func (v *TruncateScopeRequest) Equals(rhs *TruncateScopeRequest) bool {
	if !_Scope_EqualsPtr(v.Name, rhs.Name) {
		return false
	}
	return true
}

type UpsertRequest struct {
	Ref          *SchemaRef    `json:"ref,omitempty"`
	EntityValues FieldValueMap `json:"entityValues"`
}

func (v *UpsertRequest) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Ref != nil {
		w, err = v.Ref.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.EntityValues != nil {
		w, err = v.EntityValues.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *UpsertRequest) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Ref, err = _SchemaRef_Read(field.Value)
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TMap {
				v.EntityValues, err = _FieldValueMap_Read(field.Value)
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *UpsertRequest) String() string {
	if v == nil {
		return "<nil>"
	}
	var fields [2]string
	i := 0
	if v.Ref != nil {
		fields[i] = fmt.Sprintf("Ref: %v", v.Ref)
		i++
	}
	if v.EntityValues != nil {
		fields[i] = fmt.Sprintf("EntityValues: %v", v.EntityValues)
		i++
	}
	return fmt.Sprintf("UpsertRequest{%v}", strings.Join(fields[:i], ", "))
}

func (v *UpsertRequest) Equals(rhs *UpsertRequest) bool {
	if !((v.Ref == nil && rhs.Ref == nil) || (v.Ref != nil && rhs.Ref != nil && v.Ref.Equals(rhs.Ref))) {
		return false
	}
	if !((v.EntityValues == nil && rhs.EntityValues == nil) || (v.EntityValues != nil && rhs.EntityValues != nil && v.EntityValues.Equals(rhs.EntityValues))) {
		return false
	}
	return true
}

type UpsertSchemaRequest struct {
	Scope      *Scope              `json:"scope,omitempty"`
	NamePrefix *NamePrefix         `json:"namePrefix,omitempty"`
	EntityDefs []*EntityDefinition `json:"entityDefs"`
}

func (v *UpsertSchemaRequest) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Scope != nil {
		w, err = v.Scope.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.NamePrefix != nil {
		w, err = v.NamePrefix.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.EntityDefs != nil {
		w, err = wire.NewValueList(_List_EntityDefinition_ValueList(v.EntityDefs)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *UpsertSchemaRequest) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x Scope
				x, err = _Scope_Read(field.Value)
				v.Scope = &x
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x NamePrefix
				x, err = _NamePrefix_Read(field.Value)
				v.NamePrefix = &x
				if err != nil {
					return err
				}
			}
		case 3:
			if field.Value.Type() == wire.TList {
				v.EntityDefs, err = _List_EntityDefinition_Read(field.Value.GetList())
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *UpsertSchemaRequest) String() string {
	if v == nil {
		return "<nil>"
	}
	var fields [3]string
	i := 0
	if v.Scope != nil {
		fields[i] = fmt.Sprintf("Scope: %v", *(v.Scope))
		i++
	}
	if v.NamePrefix != nil {
		fields[i] = fmt.Sprintf("NamePrefix: %v", *(v.NamePrefix))
		i++
	}
	if v.EntityDefs != nil {
		fields[i] = fmt.Sprintf("EntityDefs: %v", v.EntityDefs)
		i++
	}
	return fmt.Sprintf("UpsertSchemaRequest{%v}", strings.Join(fields[:i], ", "))
}

func (v *UpsertSchemaRequest) Equals(rhs *UpsertSchemaRequest) bool {
	if !_Scope_EqualsPtr(v.Scope, rhs.Scope) {
		return false
	}
	if !_NamePrefix_EqualsPtr(v.NamePrefix, rhs.NamePrefix) {
		return false
	}
	if !((v.EntityDefs == nil && rhs.EntityDefs == nil) || (v.EntityDefs != nil && rhs.EntityDefs != nil && _List_EntityDefinition_Equals(v.EntityDefs, rhs.EntityDefs))) {
		return false
	}
	return true
}

type UpsertSchemaResponse struct {
	Versions []Version `json:"versions"`
}

func (v *UpsertSchemaResponse) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Versions != nil {
		w, err = wire.NewValueList(_List_Version_ValueList(v.Versions)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *UpsertSchemaResponse) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.Versions, err = _List_Version_Read(field.Value.GetList())
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *UpsertSchemaResponse) String() string {
	if v == nil {
		return "<nil>"
	}
	var fields [1]string
	i := 0
	if v.Versions != nil {
		fields[i] = fmt.Sprintf("Versions: %v", v.Versions)
		i++
	}
	return fmt.Sprintf("UpsertSchemaResponse{%v}", strings.Join(fields[:i], ", "))
}

func (v *UpsertSchemaResponse) Equals(rhs *UpsertSchemaResponse) bool {
	if !((v.Versions == nil && rhs.Versions == nil) || (v.Versions != nil && rhs.Versions != nil && _List_Version_Equals(v.Versions, rhs.Versions))) {
		return false
	}
	return true
}

type Value struct {
	ElemValue *RawValue `json:"elemValue,omitempty"`
}

func (v *Value) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.ElemValue != nil {
		w, err = v.ElemValue.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if i != 1 {
		return wire.Value{}, fmt.Errorf("Value should have exactly one field: got %v fields", i)
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _RawValue_Read(w wire.Value) (*RawValue, error) {
	var v RawValue
	err := v.FromWire(w)
	return &v, err
}

func (v *Value) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.ElemValue, err = _RawValue_Read(field.Value)
				if err != nil {
					return err
				}
			}
		}
	}
	count := 0
	if v.ElemValue != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Value should have exactly one field: got %v fields", count)
	}
	return nil
}

func (v *Value) String() string {
	if v == nil {
		return "<nil>"
	}
	var fields [1]string
	i := 0
	if v.ElemValue != nil {
		fields[i] = fmt.Sprintf("ElemValue: %v", v.ElemValue)
		i++
	}
	return fmt.Sprintf("Value{%v}", strings.Join(fields[:i], ", "))
}

func (v *Value) Equals(rhs *Value) bool {
	if !((v.ElemValue == nil && rhs.ElemValue == nil) || (v.ElemValue != nil && rhs.ElemValue != nil && v.ElemValue.Equals(rhs.ElemValue))) {
		return false
	}
	return true
}

type Version int32

func (v Version) ToWire() (wire.Value, error) {
	x := (int32)(v)
	return wire.NewValueI32(x), error(nil)
}

func (v Version) String() string {
	x := (int32)(v)
	return fmt.Sprint(x)
}

func (v *Version) FromWire(w wire.Value) error {
	x, err := w.GetI32(), error(nil)
	*v = (Version)(x)
	return err
}

func (lhs Version) Equals(rhs Version) bool {
	return (lhs == rhs)
}
